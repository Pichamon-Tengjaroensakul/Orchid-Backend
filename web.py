# -*- coding: utf-8 -*-
"""web.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BL6rGfcjRjgT-hPDLiIJHgnvx2CM4R33
"""

from fastapi import FastAPI, UploadFile, File
import pandas as pd
import numpy as np
import joblib
import re
import io

app = FastAPI()

# โหลดโมเดลที่เซฟไว้
artifacts = joblib.load("orchid_decision_tree_v1.pkl")
model = artifacts["model"]
le = artifacts["label_encoder"]
medians = artifacts["medians"]
feat_cols = artifacts["feature_columns"]

# --- ฟังก์ชันคำนวณสูตรคณิตศาสตร์ (ก๊อปปี้มาจากโค้ดเพื่อนคุณเป๊ะๆ ห้ามแก้) ---
def extract_peak_features(t, f):
    mask = ~np.isnan(t) & ~np.isnan(f)
    t = np.asarray(t[mask])
    f = np.asarray(f[mask])

    if len(t) < 3:
        return np.nan, np.nan, np.nan, np.nan

    sort_idx = np.argsort(t)
    t = t[sort_idx]
    f = f[sort_idx]

    peak_idx = np.argmax(f)
    F_peak = float(f[peak_idx])
    T_peak = float(t[peak_idx])
    area = float(np.trapz(f, t))

    half = F_peak / 2.0
    above_half = np.where(f >= half)[0]
    if len(above_half) >= 2:
        width = float(t[above_half[-1]] - t[above_half[0]])
    else:
        width = np.nan

    return T_peak, F_peak, width, area

def process_file(df):
    # เลียนแบบ logic การหาคู่ T/F
    columns = df.columns.tolist()
    pairs = []
    for col in columns:
        m = re.match(r"^(.*)T(\d+)$", col)
        if m:
            prefix, rep = m.group(1), m.group(2)
            f_col = f"{prefix}F{rep}"
            if f_col in columns:
                pairs.append((col, f_col))

    features = []
    for t_col, f_col in pairs:
        t_vals = df[t_col].values
        f_vals = df[f_col].values
        T_peak, F_peak, width, area = extract_peak_features(t_vals, f_vals)

        # ดึงชื่อสายพันธุ์จากชื่อไฟล์หรือชื่อคอลัมน์ (ถ้ามี) หรือใส่ Unknown
        features.append({
            "sample_id": t_col,
            "T_peak": T_peak,
            "F_peak": F_peak,
            "Width_FWHM": width,
            "Area": area
        })

    feat_df = pd.DataFrame(features)

    # แทนค่า NaN ด้วยค่า Median เดิมจากตอนเทรน (สำคัญมากเพื่อความแม่นยำ)
    for col in feat_cols:
        feat_df[col] = feat_df[col].astype(float)
        # ใช้ median ที่เซฟมาจากตอนเทรน
        if col in medians:
             feat_df[col] = feat_df[col].fillna(medians[col])

    return feat_df

@app.post("/predict")
async def predict(file: UploadFile = File(...)):
    contents = await file.read()
    df = pd.read_excel(io.BytesIO(contents))

    # 1. แปลงข้อมูล
    processed_df = process_file(df)

    if processed_df.empty:
        return {"error": "No valid T/F pairs found"}

    # 2. เตรียมข้อมูลเข้าโมเดล
    X = processed_df[feat_cols].to_numpy()

    # 3. ทำนาย
    predictions = model.predict(X)
    probabilities = model.predict_proba(X)

    # 4. แปลงผลลัพธ์กลับเป็นชื่อสายพันธุ์
    results = []
    for i, pred_idx in enumerate(predictions):
        species_name = le.inverse_transform([pred_idx])[0]
        confidence = float(np.max(probabilities[i]))

        results.append({
            "sample_id": processed_df.iloc[i]["sample_id"],
            "species": species_name,
            "confidence": confidence
        })

    return {"results": results}