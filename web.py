# -*- coding: utf-8 -*-
"""web.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jJKSdq8rTp3n7Qx3NYIkaOAjJ8xovQzW
"""

from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from typing import List
import uvicorn
import pandas as pd
import numpy as np
import joblib
import os
import re
import io
import base64
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ==========================================
# 1. SETUP & LOAD DATA
# ==========================================
MODEL_FILENAME = 'orchid_decision_tree_v1.pkl'
REF_DATA_FILENAME = 'PROJECT_DATA.xlsx'

MODEL_PATH = os.path.join(os.path.dirname(__file__), MODEL_FILENAME)
REF_PATH = os.path.join(os.path.dirname(__file__), REF_DATA_FILENAME)

model_data = None
ref_df = None

# โหลดโมเดล
try:
    if os.path.exists(MODEL_PATH):
        model_data = joblib.load(MODEL_PATH)
        print(f"✅ Model Loaded Successfully")
    else:
        print(f"❌ Model Not Found at {MODEL_PATH}")
except Exception as e:
    print(f"❌ Error loading model: {e}")

# โหลด Reference Data
try:
    if os.path.exists(REF_PATH):
        try:
            if REF_DATA_FILENAME.endswith('.csv'):
                ref_df = pd.read_csv(REF_PATH)
            else:
                ref_df = pd.read_excel(REF_PATH)
        except:
            ref_df = pd.read_excel(REF_PATH)

        # ✅ Cleaning: แปลงชื่อคอลัมน์เป็นตัวพิมพ์เล็ก และตัดช่องว่างทิ้ง
        ref_df.columns = ref_df.columns.str.strip().str.lower()
        print(f"✅ Reference Data Loaded: {len(ref_df)} rows")
    else:
        print(f"⚠️ Reference Data Not Found!")
except Exception as e:
    print(f"⚠️ Error loading reference data: {e}")

# ==========================================
# 2. HELPER FUNCTIONS
# ==========================================
def extract_peak_features(t, f):
    try:
        mask = ~np.isnan(t) & ~np.isnan(f)
        t, f = np.asarray(t[mask]), np.asarray(f[mask])
        if len(t) < 3: return np.nan, np.nan, np.nan, np.nan

        sort_idx = np.argsort(t)
        t, f = t[sort_idx], f[sort_idx]

        peak_idx = np.argmax(f)
        F_peak = float(f[peak_idx])
        T_peak = float(t[peak_idx])

        if hasattr(np, 'trapezoid'): area = float(np.trapezoid(f, x=t))
        else: area = float(np.trapz(f, t))

        half = F_peak / 2.0
        above_half = np.where(f >= half)[0]
        if len(above_half) >= 2:
            width = float(t[above_half[-1]] - t[above_half[0]])
        else: width = np.nan

        return T_peak, F_peak, width, area
    except:
        return np.nan, np.nan, np.nan, np.nan

def generate_plot_base64(user_t, user_f, species_name):
    try:
        # ตั้งค่ากราฟให้สวยงาม (ขนาดและ Font)
        plt.figure(figsize=(8, 5))

        # 1. วาดเส้น User (สีน้ำเงิน)
        plt.plot(user_t, user_f, label='Your Sample', color='#0066cc', linewidth=2.5)

        # 2. วาดเส้น Reference (สีแดง)
        if ref_df is not None and species_name != "Unknown":
            print(f"--- Searching Ref for: {species_name} ---")

            # เตรียมคำค้นหา: ตัด sp, ตัด T ท้ายคำ
            search_key = species_name.lower().replace('sp', '').strip()
            if search_key.endswith('t'): search_key = search_key[:-1]

            # ค้นหาคอลัมน์ทั้งหมดที่เข้าข่าย: "ชื่อสายพันธุ์ + T + ตัวเลข"
            # Regex: ^search_key + t + \d+
            pattern = re.compile(f"^{re.escape(search_key)}t\\d+$", re.IGNORECASE)

            cols = list(ref_df.columns)
            matched_cols = [c for c in cols if pattern.match(c)]

            target_t_col = None
            target_f_col = None

            if matched_cols:
                # เรียงลำดับชื่อคอลัมน์ (เพื่อให้ได้ T1, T2, T3...)
                # เราจะเลือกตัวแรกสุดที่เจอ (เช่น ถ้ามี T2 ก็เอา T2 เลย ไม่ต้องรอ T1)
                matched_cols.sort()
                target_t_col = matched_cols[0]

                print(f"   ✅ Selected Ref Column: {target_t_col}")

                # หา F คู่กัน (เปลี่ยน t ตัวสุดท้ายเป็น f)
                last_t = target_t_col.rfind('t')
                candidate_f = target_t_col[:last_t] + 'f' + target_t_col[last_t+1:]

                if candidate_f in cols:
                    target_f_col = candidate_f
                else:
                    print(f"   ❌ F-column not found for {target_t_col}")

            # วาดกราฟ
            if target_t_col and target_f_col:
                ref_t = pd.to_numeric(ref_df[target_t_col], errors='coerce')
                ref_f = pd.to_numeric(ref_df[target_f_col], errors='coerce')

                mask = ~np.isnan(ref_t) & ~np.isnan(ref_f)
                ref_t, ref_f = ref_t[mask], ref_f[mask]

                # Sort ตามอุณหภูมิ (สำคัญมาก ไม่งั้นกราฟยึกยือ)
                sort_idx = np.argsort(ref_t)

                plt.plot(ref_t.iloc[sort_idx], ref_f.iloc[sort_idx],
                         label=f'Ref: {species_name}',
                         color='#ff3333', linestyle='--', linewidth=2, alpha=0.8)
            else:
                print(f"❌ No matching pair found for {species_name}")

        plt.title(f"Comparison: {species_name}", fontsize=14, fontweight='bold')
        plt.xlabel("Temperature (°C)", fontsize=12)
        plt.ylabel("Fluorescence (Diff)", fontsize=12)
        plt.legend(fontsize=10)
        plt.grid(True, linestyle=':', alpha=0.6)
        plt.tight_layout()

        # Save Plot to Base64
        buf = io.BytesIO()
        plt.savefig(buf, format='png', dpi=120) # เพิ่ม DPI ให้ชัดขึ้น
        plt.close()
        buf.seek(0)
        img_str = base64.b64encode(buf.read()).decode('utf-8')
        return f"data:image/png;base64,{img_str}"

    except Exception as e:
        print(f"Plot Error: {e}")
        plt.close()
        return None

# ==========================================
# 3. API ENDPOINTS
# ==========================================
@app.get("/")
def home():
    ref_status = "Loaded" if ref_df is not None else "Not Found"
    return {"message": f"Orchid AI Ready. Ref Data: {ref_status}"}

@app.post("/predict")
async def predict(files: List[UploadFile] = File(...)):
    if not model_data:
        raise HTTPException(status_code=500, detail="Model file not found.")

    all_results = []

    try:
        for file in files:
            contents = await file.read()
            filename = file.filename.lower()
            try:
                if filename.endswith('.csv'):
                    df = pd.read_csv(io.BytesIO(contents))
                else:
                    df = pd.read_excel(io.BytesIO(contents))
            except:
                continue

            columns = df.columns.tolist()
            processed_pairs = set()

            def process_and_predict(t_arr, f_arr, sample_name):
                T_peak, F_peak, width, area = extract_peak_features(t_arr, f_arr)
                if not np.isnan(T_peak):
                    features_df = pd.DataFrame([[T_peak, F_peak, width, area]],
                                             columns=["T_peak", "F_peak", "Width_FWHM", "Area"])

                    # 1. Prediction
                    pred_idx = model_data["model"].predict(features_df)[0]
                    species_name = model_data["label_encoder"].inverse_transform([pred_idx])[0]

                    # 2. Confidence
                    probabilities = model_data["model"].predict_proba(features_df)[0]
                    confidence = round(probabilities[pred_idx] * 100, 2)

                    # 3. Plotting
                    plot_image = generate_plot_base64(t_arr, f_arr, species_name)

                    return {
                        "filename": file.filename,
                        "sample_id": sample_name,
                        "T_peak": round(T_peak, 4),
                        "F_peak": round(F_peak, 4),
                        "Width_FWHM": round(width, 4),
                        "Area": round(area, 4),
                        "predicted_species": species_name,
                        "confidence_score": f"{confidence}%",
                        "plot_image": plot_image
                    }
                return None

            # Case: T, F columns
            if 'T' in columns and 'F' in columns:
                res = process_and_predict(
                    pd.to_numeric(df['T'], errors='coerce').values,
                    pd.to_numeric(df['F'], errors='coerce').values,
                    "Uploaded-Sample"
                )
                if res: all_results.append(res)

            # Case: Multi columns
            for col in columns:
                m = re.match(r"^(.*)T(\d+)$", str(col))
                if m:
                    prefix, num = m.group(1), m.group(2)
                    f_col = f"{prefix}F{num}"
                    if f_col in columns and col not in processed_pairs:
                        processed_pairs.add(col)
                        res = process_and_predict(
                            pd.to_numeric(df[col], errors='coerce').values,
                            pd.to_numeric(df[f_col], errors='coerce').values,
                            f"{prefix}-{num}"
                        )
                        if res: all_results.append(res)

        if not all_results:
             return {"success": False, "message": "No valid data found."}

        return {"success": True, "results": all_results}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 8000))
    uvicorn.run(app, host='0.0.0.0', port=port)