# -*- coding: utf-8 -*-
"""web.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RlkudOCWdhQo_1Wce8KJHy--lUJsggjt
"""

from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import pandas as pd
import numpy as np
import os
import re
import io

app = FastAPI()

# ตั้งค่า CORS ให้เว็บไซต์เชื่อมต่อได้
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ==========================================
# 1. ฟังก์ชันคำนวณ Feature (หัวใจหลัก)
# ==========================================
def extract_peak_features(t, f):
    try:
        # กรองค่าว่าง (NaN)
        mask = ~np.isnan(t) & ~np.isnan(f)
        t, f = np.asarray(t[mask]), np.asarray(f[mask])

        if len(t) < 3: return np.nan, np.nan, np.nan, np.nan

        # เรียงลำดับข้อมูล
        sort_idx = np.argsort(t)
        t, f = t[sort_idx], f[sort_idx]

        # 1. หาจุดยอด (Peak)
        peak_idx = np.argmax(f)
        F_peak = float(f[peak_idx])
        T_peak = float(t[peak_idx])

        # 2. หาพื้นที่ใต้กราฟ (Area)
        if hasattr(np, 'trapezoid'): area = float(np.trapezoid(f, x=t))
        else: area = float(np.trapz(f, t))

        # 3. หาความกว้าง (FWHM)
        half = F_peak / 2.0
        above_half = np.where(f >= half)[0]
        if len(above_half) >= 2:
            width = float(t[above_half[-1]] - t[above_half[0]])
        else: width = np.nan

        return T_peak, F_peak, width, area
    except:
        return np.nan, np.nan, np.nan, np.nan

# ==========================================
# 2. API Endpoints
# ==========================================
@app.get("/")
def home():
    return {"message": "Feature Extraction API is Running!"}

@app.post("/predict")
async def predict(file: UploadFile = File(...)):
    try:
        # อ่านไฟล์ Excel จาก Memory
        contents = await file.read()
        df = pd.read_excel(io.BytesIO(contents))

        results = []
        columns = df.columns.tolist()
        processed_pairs = set()

        # --- กรณีที่ 1: ไฟล์มีแค่คอลัมน์ T และ F (เหมือนไฟล์ตัวอย่าง) ---
        if 'T' in columns and 'F' in columns:
            t_vals = pd.to_numeric(df['T'], errors='coerce').values
            f_vals = pd.to_numeric(df['F'], errors='coerce').values

            # คำนวณ Feature
            T_peak, F_peak, width, area = extract_peak_features(t_vals, f_vals)

            if not np.isnan(T_peak):
                results.append({
                    "sample_id": "Uploaded-Sample",
                    "T_peak": round(T_peak, 2),
                    "F_peak": round(F_peak, 4),
                    "Width_FWHM": round(width, 4),
                    "Area": round(area, 4)
                    # ❌ ไม่ส่งค่า predicted_species
                })

        # --- กรณีที่ 2: ไฟล์มีหลายคอลัมน์ (เช่น SampleT1, SampleF1) ---
        for col in columns:
            m = re.match(r"^(.*)T(\d+)$", str(col))
            if m:
                prefix, num = m.group(1), m.group(2)
                f_col = f"{prefix}F{num}"

                if f_col in columns and col not in processed_pairs:
                    processed_pairs.add(col)

                    t_vals = pd.to_numeric(df[col], errors='coerce').values
                    f_vals = pd.to_numeric(df[f_col], errors='coerce').values

                    T_peak, F_peak, width, area = extract_peak_features(t_vals, f_vals)

                    if not np.isnan(T_peak):
                        results.append({
                            "sample_id": f"{prefix}-{num}",
                            "T_peak": round(T_peak, 2),
                            "F_peak": round(F_peak, 4),
                            "Width_FWHM": round(width, 4),
                            "Area": round(area, 4)
                        })

        if not results:
             return {"success": False, "message": "No valid data found in file."}

        return {"success": True, "results": results}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 8000))
    uvicorn.run(app, host='0.0.0.0', port=port)