# -*- coding: utf-8 -*-
"""web.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jJKSdq8rTp3n7Qx3NYIkaOAjJ8xovQzW
"""

from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from typing import List
import uvicorn
import pandas as pd
import numpy as np
import joblib
import os
import re
import io
import base64
import matplotlib
matplotlib.use('Agg') # ใช้ Backend แบบไม่แสดงหน้าต่าง (จำเป็นสำหรับ Server)
import matplotlib.pyplot as plt

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ==========================================
# 1. SETUP & LOAD DATA
# ==========================================
MODEL_FILENAME = 'orchid_decision_tree_v1.pkl'
REF_DATA_FILENAME = 'PROJECT_DATA.xlsx'

MODEL_PATH = os.path.join(os.path.dirname(__file__), MODEL_FILENAME)
REF_PATH = os.path.join(os.path.dirname(__file__), REF_DATA_FILENAME)

model_data = None
ref_df = None

# 1.1 โหลดโมเดล
try:
    if os.path.exists(MODEL_PATH):
        model_data = joblib.load(MODEL_PATH)
        print(f"✅ Model Loaded Successfully")
    else:
        print(f"❌ Model Not Found at {MODEL_PATH}")
except Exception as e:
    print(f"❌ Error loading model: {e}")

# 1.2 โหลด Reference Data (PROJECT_DATA.xlsx)
try:
    if os.path.exists(REF_PATH):
        # พยายามโหลดไฟล์ (รองรับทั้ง csv และ excel)
        try:
            if REF_DATA_FILENAME.endswith('.csv'):
                ref_df = pd.read_csv(REF_PATH)
            else:
                ref_df = pd.read_excel(REF_PATH)
        except:
            ref_df = pd.read_excel(REF_PATH)

        # ✅ Cleaning: ลบช่องว่างหัวท้ายชื่อคอลัมน์
        ref_df.columns = ref_df.columns.str.strip()
        print(f"✅ Reference Data Loaded: {len(ref_df)} rows")
    else:
        print(f"⚠️ Reference Data Not Found! (Reference lines will not show)")
except Exception as e:
    print(f"⚠️ Error loading reference data: {e}")

# ==========================================
# 2. HELPER FUNCTIONS
# ==========================================
def extract_peak_features(t, f):
    try:
        mask = ~np.isnan(t) & ~np.isnan(f)
        t, f = np.asarray(t[mask]), np.asarray(f[mask])
        if len(t) < 3: return np.nan, np.nan, np.nan, np.nan

        sort_idx = np.argsort(t)
        t, f = t[sort_idx], f[sort_idx]

        peak_idx = np.argmax(f)
        F_peak = float(f[peak_idx])
        T_peak = float(t[peak_idx])

        if hasattr(np, 'trapezoid'): area = float(np.trapezoid(f, x=t))
        else: area = float(np.trapz(f, t))

        half = F_peak / 2.0
        above_half = np.where(f >= half)[0]
        if len(above_half) >= 2:
            width = float(t[above_half[-1]] - t[above_half[0]])
        else: width = np.nan

        return T_peak, F_peak, width, area
    except:
        return np.nan, np.nan, np.nan, np.nan

def generate_plot_base64(user_t, user_f, species_name):
    """
    ฟังก์ชันวาดกราฟ:
    - วาดเส้น Reference ทั้งหมดที่เกี่ยวข้องกับสายพันธุ์ (สีแดงจางๆ)
    - วาดเส้น User Data ทับลงไป (สีดำหนา)
    """
    try:
        plt.figure(figsize=(8, 5))

        # ---------------------------------------------------------
        # ส่วนที่ 1: วาดเส้น Reference (PROJECT_DATA) ไว้ข้างหลัง
        # ---------------------------------------------------------
        has_ref = False
        if ref_df is not None and species_name != "Unknown":
            # เตรียมคำค้นหา: ตัดคำว่า sp, ตัดตัว T ท้ายคำ
            clean_name = species_name.replace('sp', '').strip()
            if clean_name.endswith('T') or clean_name.endswith('t'):
                 clean_name = clean_name[:-1]

            # แปลงเป็นตัวพิมพ์เล็กเพื่อค้นหาแบบ case-insensitive
            clean_name_lower = clean_name.lower()
            cols = list(ref_df.columns)

            # วนลูปหา "ทุกคอลัมน์" ที่ตรงกับสายพันธุ์นี้ เพื่อวาดเป็นกลุ่ม
            for col in cols:
                col_lower = col.lower()

                # เช็คว่าชื่อคอลัมน์มีชื่อสายพันธุ์ และเป็นคอลัมน์ T (มี T ตามด้วยตัวเลข)
                if clean_name_lower in col_lower and 't' in col_lower and any(c.isdigit() for c in col):

                    # หาคู่ F ของมัน (เปลี่ยน T ตัวสุดท้ายเป็น F)
                    # เราต้องหาตำแหน่ง T ตัวสุดท้ายในชื่อจริง (Original Case)
                    is_upper_t = 'T' in col
                    last_t_idx = col.rfind('T') if is_upper_t else col.rfind('t')

                    # สร้างชื่อ F ที่คาดหวัง
                    col_f = col[:last_t_idx] + ('F' if is_upper_t else 'f') + col[last_t_idx+1:]

                    # ถ้ามีคอลัมน์ F คู่กัน ให้วาดเส้น
                    if col_f in cols:
                        ref_t = pd.to_numeric(ref_df[col], errors='coerce')
                        ref_f = pd.to_numeric(ref_df[col_f], errors='coerce')

                        mask = ~np.isnan(ref_t) & ~np.isnan(ref_f)
                        ref_t, ref_f = ref_t[mask], ref_f[mask]
                        sort_idx = np.argsort(ref_t)

                        # วาดเส้น Reference เป็นสีแดงจางๆ (alpha=0.4)
                        plt.plot(ref_t.iloc[sort_idx], ref_f.iloc[sort_idx],
                                 color='#ff3333', linestyle='--', linewidth=1, alpha=0.3)
                        has_ref = True

        # ---------------------------------------------------------
        # ส่วนที่ 2: วาดเส้น User (Test Data) เป็น "เส้นสีดำหนา"
        # ---------------------------------------------------------
        plt.plot(user_t, user_f, label='Your Sample', color='black', linewidth=2.5)

        # ตกแต่งกราฟ
        plt.title(f"Comparison: {species_name}", fontsize=14, fontweight='bold')
        plt.xlabel("Temperature (°C)", fontsize=12)
        plt.ylabel("Fluorescence (Diff)", fontsize=12)

        # สร้าง Legend แบบกำหนดเอง (เพื่อให้ดูสะอาดตา)
        from matplotlib.lines import Line2D
        legend_elements = [
            Line2D([0], [0], color='black', lw=2.5, label='Your Sample'),
        ]
        if has_ref:
            legend_elements.append(Line2D([0], [0], color='#ff3333', lw=1, linestyle='--', label=f'Ref: {species_name}'))

        plt.legend(handles=legend_elements, loc='upper right')
        plt.grid(True, linestyle=':', alpha=0.6)
        plt.tight_layout()

        # แปลงกราฟเป็น Base64 ส่งกลับไป
        buf = io.BytesIO()
        plt.savefig(buf, format='png', dpi=120)
        plt.close()
        buf.seek(0)
        img_str = base64.b64encode(buf.read()).decode('utf-8')
        return f"data:image/png;base64,{img_str}"

    except Exception as e:
        print(f"Plot Error: {e}")
        plt.close()
        return None

# ==========================================
# 3. API ENDPOINTS
# ==========================================
@app.get("/")
def home():
    ref_status = "Loaded" if ref_df is not None else "Not Found"
    return {"message": f"Orchid AI Ready. Ref Data: {ref_status}"}

@app.post("/predict")
async def predict(files: List[UploadFile] = File(...)):
    if not model_data:
        raise HTTPException(status_code=500, detail="Model file not found.")

    all_results = []

    try:
        for file in files:
            contents = await file.read()
            filename = file.filename.lower()
            try:
                # อ่านไฟล์
                if filename.endswith('.csv'):
                    df = pd.read_csv(io.BytesIO(contents))
                else:
                    df = pd.read_excel(io.BytesIO(contents))
            except:
                continue

            columns = df.columns.tolist()
            processed_pairs = set()

            # ฟังก์ชันย่อยสำหรับประมวลผลแต่ละคู่ T,F
            def process_and_predict(t_arr, f_arr, sample_name):
                T_peak, F_peak, width, area = extract_peak_features(t_arr, f_arr)
                if not np.isnan(T_peak):
                    features_df = pd.DataFrame([[T_peak, F_peak, width, area]],
                                             columns=["T_peak", "F_peak", "Width_FWHM", "Area"])

                    # 1. ทำนายผล
                    pred_idx = model_data["model"].predict(features_df)[0]
                    species_name = model_data["label_encoder"].inverse_transform([pred_idx])[0]

                    # 2. คำนวณความมั่นใจ (%)
                    probabilities = model_data["model"].predict_proba(features_df)[0]
                    confidence = round(probabilities[pred_idx] * 100, 2)

                    # 3. สร้างกราฟ (Reference + User Plot)
                    plot_image = generate_plot_base64(t_arr, f_arr, species_name)

                    return {
                        "filename": file.filename,
                        "sample_id": sample_name,
                        "T_peak": round(T_peak, 4),
                        "F_peak": round(F_peak, 4),
                        "Width_FWHM": round(width, 4),
                        "Area": round(area, 4),
                        "predicted_species": species_name,
                        "confidence_score": f"{confidence}%",
                        "plot_image": plot_image
                    }
                return None

            # กรณีที่ 1: ไฟล์มีคอลัมน์ T และ F เดี่ยวๆ (User Upload)
            if 'T' in columns and 'F' in columns:
                res = process_and_predict(
                    pd.to_numeric(df['T'], errors='coerce').values,
                    pd.to_numeric(df['F'], errors='coerce').values,
                    "Uploaded-Sample"
                )
                if res: all_results.append(res)

            # กรณีที่ 2: ไฟล์มีหลายคอลัมน์ (เช่น T1, F1, T2, F2...)
            for col in columns:
                m = re.match(r"^(.*)T(\d+)$", str(col))
                if m:
                    prefix, num = m.group(1), m.group(2)
                    f_col = f"{prefix}F{num}"
                    if f_col in columns and col not in processed_pairs:
                        processed_pairs.add(col)
                        res = process_and_predict(
                            pd.to_numeric(df[col], errors='coerce').values,
                            pd.to_numeric(df[f_col], errors='coerce').values,
                            f"{prefix}-{num}"
                        )
                        if res: all_results.append(res)

        if not all_results:
             return {"success": False, "message": "No valid data found."}

        return {"success": True, "results": all_results}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 8000))
    uvicorn.run(app, host='0.0.0.0', port=port)