# -*- coding: utf-8 -*-
"""web.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fcAa0tjhjrTcbUYgvyOXQTFJCTOQEq5M
"""

from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import pandas as pd
import numpy as np
import joblib
import os
import re
import io

app = FastAPI()

# ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ CORS ‡πÉ‡∏´‡πâ Frontend (Lovable) ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ==========================================
# 1. ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• AI
# ==========================================
# ‚ö†Ô∏è ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏µ‡πâ‡∏Ç‡∏∂‡πâ‡∏ô GitHub ‡∏î‡πâ‡∏ß‡∏¢
MODEL_FILENAME = 'orchid_decision_tree_v1.pkl'
MODEL_PATH = os.path.join(os.path.dirname(__file__), MODEL_FILENAME)
model_data = None

try:
    if os.path.exists(MODEL_PATH):
        model_data = joblib.load(MODEL_PATH)
        print(f"‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {MODEL_FILENAME}")
    else:
        print(f"‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏µ‡πà: {MODEL_PATH}")
        print("üëâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå .pkl ‡∏Ç‡∏∂‡πâ‡∏ô GitHub ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢")
except Exception as e:
    print(f"‚ùå Error loading model: {e}")

# ==========================================
# 2. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Feature (Logic ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏ï‡∏≠‡∏ô‡πÄ‡∏ó‡∏£‡∏ô)
# ==========================================
def extract_peak_features(t, f):
    try:
        mask = ~np.isnan(t) & ~np.isnan(f)
        t, f = np.asarray(t[mask]), np.asarray(f[mask])

        if len(t) < 3: return np.nan, np.nan, np.nan, np.nan

        sort_idx = np.argsort(t)
        t, f = t[sort_idx], f[sort_idx]

        peak_idx = np.argmax(f)
        F_peak = float(f[peak_idx])
        T_peak = float(t[peak_idx])

        if hasattr(np, 'trapezoid'): area = float(np.trapezoid(f, x=t))
        else: area = float(np.trapz(f, t))

        half = F_peak / 2.0
        above_half = np.where(f >= half)[0]
        if len(above_half) >= 2:
            width = float(t[above_half[-1]] - t[above_half[0]])
        else: width = np.nan

        return T_peak, F_peak, width, area
    except:
        return np.nan, np.nan, np.nan, np.nan

# ==========================================
# 3. API Endpoints
# ==========================================
@app.get("/")
def home():
    status = "‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô (Model Loaded)" if model_data else "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏° (Model Not Found)"
    return {"message": f"Orchid AI Backend: {status}"}

@app.post("/predict")
async def predict(file: UploadFile = File(...)):
    # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÑ‡∏´‡∏° ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÅ‡∏à‡πâ‡∏á Error
    if not model_data:
        raise HTTPException(status_code=500, detail="Server Error: Model file (.pkl) not found.")

    try:
        contents = await file.read()
        df = pd.read_excel(io.BytesIO(contents))

        results = []
        columns = df.columns.tolist()
        processed_pairs = set()

        # ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏¢‡πà‡∏≠‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á
        def process_and_predict(t_arr, f_arr, sample_name):
            T_peak, F_peak, width, area = extract_peak_features(t_arr, f_arr)

            if not np.isnan(T_peak):
                # ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢ (‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ 4 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏ó‡∏£‡∏ô‡∏°‡∏≤)
                features_df = pd.DataFrame([[T_peak, F_peak, width, area]],
                                         columns=["T_peak", "F_peak", "Width_FWHM", "Area"])

                # ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ú‡∏•‡∏î‡πâ‡∏ß‡∏¢‡πÇ‡∏°‡πÄ‡∏î‡∏•
                pred_idx = model_data["model"].predict(features_df)[0]
                species_name = model_data["label_encoder"].inverse_transform([pred_idx])[0]

                return {
                    "sample_id": sample_name,
                    "T_peak": round(T_peak, 4),      # ‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏° 4 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
                    "F_peak": round(F_peak, 4),      # ‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏° 4 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
                    "Width_FWHM": round(width, 4),   # ‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏° 4 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
                    "Area": round(area, 4),          # ‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏° 4 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
                    "predicted_species": species_name
                }
            return None

        # --- ‡∏Å‡∏£‡∏ì‡∏µ 1: ‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏µ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå T, F (‡πÅ‡∏ö‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì) ---
        if 'T' in columns and 'F' in columns:
            t_vals = pd.to_numeric(df['T'], errors='coerce').values
            f_vals = pd.to_numeric(df['F'], errors='coerce').values
            res = process_and_predict(t_vals, f_vals, "Uploaded-Sample")
            if res: results.append(res)

        # --- ‡∏Å‡∏£‡∏ì‡∏µ 2: ‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏µ‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå (SampleT1, SampleF1) ---
        for col in columns:
            m = re.match(r"^(.*)T(\d+)$", str(col))
            if m:
                prefix, num = m.group(1), m.group(2)
                f_col = f"{prefix}F{num}"

                if f_col in columns and col not in processed_pairs:
                    processed_pairs.add(col)

                    t_vals = pd.to_numeric(df[col], errors='coerce').values
                    f_vals = pd.to_numeric(df[f_col], errors='coerce').values

                    res = process_and_predict(t_vals, f_vals, f"{prefix}-{num}")
                    if res: results.append(res)

        if not results:
             return {"success": False, "message": "No valid data found in Excel file."}

        return {"success": True, "results": results}

    except Exception as e:
        print(f"Error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 8000))
    uvicorn.run(app, host='0.0.0.0', port=port)